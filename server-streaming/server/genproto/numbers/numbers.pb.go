// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: numbers/numbers.proto

package numbers

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type NumberRequest struct {
	Max                  int32    `protobuf:"varint,1,opt,name=max,proto3" json:"max"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NumberRequest) Reset()         { *m = NumberRequest{} }
func (m *NumberRequest) String() string { return proto.CompactTextString(m) }
func (*NumberRequest) ProtoMessage()    {}
func (*NumberRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_43142302077a0a65, []int{0}
}
func (m *NumberRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NumberRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NumberRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NumberRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NumberRequest.Merge(m, src)
}
func (m *NumberRequest) XXX_Size() int {
	return m.Size()
}
func (m *NumberRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NumberRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NumberRequest proto.InternalMessageInfo

func (m *NumberRequest) GetMax() int32 {
	if m != nil {
		return m.Max
	}
	return 0
}

type NumberResponse struct {
	Number               int32    `protobuf:"varint,1,opt,name=number,proto3" json:"number"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NumberResponse) Reset()         { *m = NumberResponse{} }
func (m *NumberResponse) String() string { return proto.CompactTextString(m) }
func (*NumberResponse) ProtoMessage()    {}
func (*NumberResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_43142302077a0a65, []int{1}
}
func (m *NumberResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NumberResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NumberResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NumberResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NumberResponse.Merge(m, src)
}
func (m *NumberResponse) XXX_Size() int {
	return m.Size()
}
func (m *NumberResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_NumberResponse.DiscardUnknown(m)
}

var xxx_messageInfo_NumberResponse proto.InternalMessageInfo

func (m *NumberResponse) GetNumber() int32 {
	if m != nil {
		return m.Number
	}
	return 0
}

func init() {
	proto.RegisterType((*NumberRequest)(nil), "numbers.NumberRequest")
	proto.RegisterType((*NumberResponse)(nil), "numbers.NumberResponse")
}

func init() { proto.RegisterFile("numbers/numbers.proto", fileDescriptor_43142302077a0a65) }

var fileDescriptor_43142302077a0a65 = []byte{
	// 158 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x12, 0xcd, 0x2b, 0xcd, 0x4d,
	0x4a, 0x2d, 0x2a, 0xd6, 0x87, 0xd2, 0x7a, 0x05, 0x45, 0xf9, 0x25, 0xf9, 0x42, 0xec, 0x50, 0xae,
	0x92, 0x22, 0x17, 0xaf, 0x1f, 0x98, 0x19, 0x94, 0x5a, 0x58, 0x9a, 0x5a, 0x5c, 0x22, 0x24, 0xc0,
	0xc5, 0x9c, 0x9b, 0x58, 0x21, 0xc1, 0xa8, 0xc0, 0xa8, 0xc1, 0x1a, 0x04, 0x62, 0x2a, 0x69, 0x70,
	0xf1, 0xc1, 0x94, 0x14, 0x17, 0xe4, 0xe7, 0x15, 0xa7, 0x0a, 0x89, 0x71, 0xb1, 0x41, 0xf4, 0x43,
	0x95, 0x41, 0x79, 0x46, 0x01, 0x30, 0xc3, 0x82, 0x53, 0x8b, 0xca, 0x32, 0x93, 0x53, 0x85, 0xec,
	0xb9, 0xb8, 0xdc, 0x53, 0x4b, 0x20, 0x62, 0xc5, 0x42, 0x62, 0x7a, 0x30, 0x47, 0xa0, 0x58, 0x29,
	0x25, 0x8e, 0x21, 0x0e, 0xb1, 0xc7, 0x80, 0xd1, 0x49, 0xe0, 0xc4, 0x23, 0x39, 0xc6, 0x0b, 0x8f,
	0xe4, 0x18, 0x1f, 0x3c, 0x92, 0x63, 0x9c, 0xf1, 0x58, 0x8e, 0x21, 0x89, 0x0d, 0xec, 0x01, 0x63,
	0x40, 0x00, 0x00, 0x00, 0xff, 0xff, 0x74, 0x06, 0x30, 0xac, 0xd9, 0x00, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// NumberServiceClient is the client API for NumberService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type NumberServiceClient interface {
	GetNumbers(ctx context.Context, in *NumberRequest, opts ...grpc.CallOption) (NumberService_GetNumbersClient, error)
}

type numberServiceClient struct {
	cc *grpc.ClientConn
}

func NewNumberServiceClient(cc *grpc.ClientConn) NumberServiceClient {
	return &numberServiceClient{cc}
}

func (c *numberServiceClient) GetNumbers(ctx context.Context, in *NumberRequest, opts ...grpc.CallOption) (NumberService_GetNumbersClient, error) {
	stream, err := c.cc.NewStream(ctx, &_NumberService_serviceDesc.Streams[0], "/numbers.NumberService/GetNumbers", opts...)
	if err != nil {
		return nil, err
	}
	x := &numberServiceGetNumbersClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NumberService_GetNumbersClient interface {
	Recv() (*NumberResponse, error)
	grpc.ClientStream
}

type numberServiceGetNumbersClient struct {
	grpc.ClientStream
}

func (x *numberServiceGetNumbersClient) Recv() (*NumberResponse, error) {
	m := new(NumberResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// NumberServiceServer is the server API for NumberService service.
type NumberServiceServer interface {
	GetNumbers(*NumberRequest, NumberService_GetNumbersServer) error
}

// UnimplementedNumberServiceServer can be embedded to have forward compatible implementations.
type UnimplementedNumberServiceServer struct {
}

func (*UnimplementedNumberServiceServer) GetNumbers(req *NumberRequest, srv NumberService_GetNumbersServer) error {
	return status.Errorf(codes.Unimplemented, "method GetNumbers not implemented")
}

func RegisterNumberServiceServer(s *grpc.Server, srv NumberServiceServer) {
	s.RegisterService(&_NumberService_serviceDesc, srv)
}

func _NumberService_GetNumbers_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(NumberRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NumberServiceServer).GetNumbers(m, &numberServiceGetNumbersServer{stream})
}

type NumberService_GetNumbersServer interface {
	Send(*NumberResponse) error
	grpc.ServerStream
}

type numberServiceGetNumbersServer struct {
	grpc.ServerStream
}

func (x *numberServiceGetNumbersServer) Send(m *NumberResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _NumberService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "numbers.NumberService",
	HandlerType: (*NumberServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetNumbers",
			Handler:       _NumberService_GetNumbers_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "numbers/numbers.proto",
}

func (m *NumberRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NumberRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NumberRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Max != 0 {
		i = encodeVarintNumbers(dAtA, i, uint64(m.Max))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NumberResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NumberResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NumberResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Number != 0 {
		i = encodeVarintNumbers(dAtA, i, uint64(m.Number))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintNumbers(dAtA []byte, offset int, v uint64) int {
	offset -= sovNumbers(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *NumberRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Max != 0 {
		n += 1 + sovNumbers(uint64(m.Max))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NumberResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Number != 0 {
		n += 1 + sovNumbers(uint64(m.Number))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovNumbers(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozNumbers(x uint64) (n int) {
	return sovNumbers(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *NumberRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNumbers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NumberRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NumberRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Max", wireType)
			}
			m.Max = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNumbers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Max |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNumbers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNumbers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NumberResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNumbers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NumberResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NumberResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNumbers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNumbers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNumbers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNumbers(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNumbers
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNumbers
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNumbers
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthNumbers
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupNumbers
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthNumbers
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthNumbers        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNumbers          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupNumbers = fmt.Errorf("proto: unexpected end of group")
)
